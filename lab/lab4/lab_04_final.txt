Michael Dang

4 Making Assumptions
1.
sizeof(char)    = 1
sizeof(char &)  = 1
sizeof(char *)  = 8
sizeof(short)   = 2
sizeof(short &) = 2
sizeof(short *) = 8
sizeof(int)     = 4
sizeof(int &)   = 4
sizeof(int *)   = 8
sizeof(long)    = 8
sizeof(long &)  = 8
sizeof(long *)  = 8
sizeof(int **)  = 8
sizeof(int ***) = 8


(a) char     | sizeof(char)    = 1 bit
(b) char &   | sizeof(char &)  = 1 bit
(c) char *   | sizeof(char *)  = 8 bits
(d) short    | sizeof(short)   = 2 bits
(e) short &  | sizeof(short &) = 2 bits
(f) short *  | sizeof(short *) = 8 bits
(g) int      | sizeof(int)     = 4 bits
(h) int &    | sizeof(int &)   = 4 bits
(i) int *    | sizeof(int *)   = 8 bits
(j) long     | sizeof(long)    = 8 bits
(k) long &   | sizeof(long &)  = 8 bits
(l) long *   | sizeof(long *)  = 8 bits
(m) int **   | sizeof(int **)  = 8 bits
(n) int ***  | sizeof(int ***) = 8 bits


2.
(a) 0x00007ffd0f811b840x7ffd0f811b86
(b) 0x7ffd0f811b88
(c) 0x7ffd0f811b8a
(d) 0x7ffd0f811b8c
(e) ...

We have to use reinterpret_cast to force the assignment of the arbitrary address to the pointer instead of a simple because in c++ address is representing as a pointer

3.

Run Number 1
dang@nike:~/Dang-Michael-lab04$ ./making_assumptions_3
(a) : 0x7ffe330ec624
(b) : 0x7ffe330ec628
(c) : 0x7ffe330ec62c
(d) : 0x7ffe330ec630
(e) : 0x7ffe330ec634

Run Number 2
dang@nike:~/Dang-Michael-lab04$ ./making_assumptions_3
(a) : 0x7ffc5df80d64
(b) : 0x7ffc5df80d68
(c) : 0x7ffc5df80d6c
(d) : 0x7ffc5df80d70
(e) : 0x7ffc5df80d74

Run Number 3
dang@nike:~/Dang-Michael-lab04$ ./making_assumptions_3
(a) : 0x7ffed2cdbac4
(b) : 0x7ffed2cdbac8
(c) : 0x7ffed2cdbacc
(d) : 0x7ffed2cdbad0
(e) : 0x7ffed2cdbad4

(f) The output for each run is different. because

Every single time a program is run, the program OS allocate to it different part of memory. Therefore one cannot expect the same memory address even though it is the same variable.

------------------------------------------------------
5. Warmup Activity

1.
Compile and run
dang@nike:~/Dang-Michael-lab04$ ./warmup_activity_1

Run Number 1
integer1 = 10
p1 = 0x7ffea17e6fc4
p2 = 0x7ffea17e6fb8

Run Number 2
integer1 = 10
p1 = 0x7fff5166d378
p2 = 0x7fff5166d370

2.
Suppose after the declaration of variables integer1, p1, and p2, we have the following memory map:
Symbol Name 	Type 		Memory Address 		Value
integer1 		int 		80					10
p1 				int * 		84					0x7ffea17e6fc4
p2 				int ** 		92					0x7ffea17e6fb8

(a) Fill in the \Value" column in the in the memory map to reflect the changes that are caused by lines 11, 12, and 13.

integer1 = 10
p1 = 0x7fff5166d378
p2 = 0x7fff5166d370

(b) If we substitute lines 15-17 with the the following two statements, then what will be the output of the program?
	(*p1)++;
	cout << "integer1 = " << *p1 << endl;


$ g++ -Wall -std=c++14 -g -O0 -pedantic-errors -c warmup_activity_1_copy.cpp
michaeldang$ g++ -o warmup_activity_1_copy warmup_activity_1_copy.o
michaeldang$ ./warmup_activity_1_copy

integer1 = 11


(c) Will the output of the program be the same if we substitute the above two lines with the following two statements?
	integer1++;
	cout << "integer1 = " << *p1 << endl;

(d) Will the output of the program be the same if we substitute the above two lines with the following two statements?
	*p2++;
	cout << "integer1 = " << integer1 << endl;

michaeldang$ g++ -Wall -std=c++14 -g -O0 -pedantic-errors -c warmup_activity_1_copy2.cpp
michaeldang$ g++ -o warmup_activity_1_copy2 warmup_activity_1_copy2.o
michaeldang$ ./warmup_activity_1_copy2

integer1 = 11

Yes

(e) The outputs of parts (c) and (d) are the same because integer1++; and (*p1)++; increase the value of integer1 by 1, a pointer and a reference both occupy the same amount of memory.


pointer to an integer called 

 proof below:

// mapping out the code for the program with the following:
	integer1++;
	cout << "integer1 = " << *p1 << endl;

integer1  // int
p1        // pointer
p2        // pointer

integer1     10 // int
p1           10 // integer1
p2           10 // p2

integer1     11 // int, gets incremented by 1 by integer1++;
p1           11 // integer1
p2           11 // p2

integer1 = 11
output: 11


// mapping out the code for the program with the following:

	*p2++;
	cout << "integer1 = " << integer1 << endl;

integer1  // int
p1        // pointer
p2        // pointer

integer1     10 // int
p1           10 // integer1
p2           10 // p1

integer1     11 // int, gets incremented by 1 by (*p1)++; 
p1           11 // integer1
p2           11 // p1

integer1 = 11
output: 11

3.
$ g++ -Wall -std=c++14 -g -O0 -pedantic-errors -c warmup_activity_part3.cpp
warmup_activity_part3.cpp:6:4: error: assigning to 'int **' from incompatible type 'int *'; take the
      address with &
p2 = p1;
   ^ ~~
     &
1 error generated.

(a) p1 is a pointer, i.e. a pointer to an int p1, p2 is a pointer to a pointer because the ** denotes a pointer to a pointer.
(b) The program will not compile because error: assigning to 'int **' from incompatible type 'int *'; i.e. cannot convert 'int*' to 'int**' in assignment
-----------------------------------------------------
6. Arrays and Pointer Activity

1.

dang@nike:~/Dang-Michael-lab04$ make
g++ -o making_assumptions making_assumptions_1.o
make: Circular arrays_and_pointers_activity1.o <- arrays_and_pointers_activity1.o dependency dropped.
g++ -Wall -std=c++14 -g -O0 -pedantic-errors -c arrays_and_pointers_activity1.cpp
arrays_and_pointers_activity1.cpp: In function ‘int main()’:
arrays_and_pointers_activity1.cpp:9:21: warning: variable ‘p1’ set but not used [-Wunused-but-set-variable]
  int iarray [10], * p1, * p2;
                     ^~
g++ -o arrays_and_pointers_activity1 arrays_and_pointers_activity1.o


dang@nike:~/Dang-Michael-lab04$ ./arrays_and_pointers_activity1
0
1
2
3
4
5
6
7
8
9

(a) array of type ints

(b) 0 int 0, 1 int 1, 2 int 2, 3 int 3, 4 int 4, 5 int 5, 6 int 6, 7 int 7, 8 int 8, 9 int 9.

(c) an error: cannot convert 'int* [10]' to 'int*' in assignment

(d) the output of the program is
0
1
2
3
4
5
6
7
8
9

(e) No, because they both fill the array with ints starting from 0 to 9 
(f) No, because they both loop through the array to each value and output them
(g) No, the output is the same because p2 stil points to iarray even though p1 gets a garbage value.



2.

g++ -Wall -std=c++14 -g -O0 -pedantic-errors -c arrays_and_pointers_activity2.cpp
arrays_and_pointers_activity2.cpp: In function ‘int main()’:
arrays_and_pointers_activity2.cpp:9:8: warning: unused variable ‘px’ [-Wunused-variable]
  int * px = &x;
        ^~
arrays_and_pointers_activity2.cpp:13:8: warning: unused variable ‘p2’ [-Wunused-variable]
  int * p2 = b;
        ^~
arrays_and_pointers_activity2.cpp:15:8: warning: variable ‘ap1’ set but not used [-Wunused-but-set-variable]
  int * ap1 [3];
        ^~~
arrays_and_pointers_activity2.cpp:19:9: warning: variable ‘ap2’ set but not used [-Wunused-but-set-variable]
  int (* ap2 [2]) [10];
         ^~~
g++ -o arrays_and_pointers_activity2 arrays_and_pointers_activity2.o


(a) Complete the memory map given below.

Symbol 		Address 		Value 			Meaning of Symbol's Type
x 			addr-x 			10 				an int
px 			addr-px 		addr-x 			a pointer to an int
a 			addr-a 			addr-a[0] 		an array of 10 ints
a[0] 		addr-a[0]		100 			an int
a[1]		addr-a[1]		100				an int
a[2]		addr-a[2]		100				an int
a[3]		addr-a[3]		100				an int
a[4]		addr-a[4]		100				an int
a[5]		addr-a[5]		100				an int
a[6]		addr-a[6]		100				an int
a[7]		addr-a[7]		100				an int
a[8]		addr-a[8]		100				an int
b 			addr-b 			addr-b[0] 		an array of 5 ints
b[0] 		addr-b[0]		1000			an int
b[1]		addr-b[1]		1000			an int
b[2]		addr-b[2]		1000			an int
b[3]		addr-b[3]		1000			an int
b[4]		addr-b[4]		1000			an int
p1 			addr-p1			addr-a[0]		a pointer to an int
p2			addr-p2			addr-b[0]		a pointer to an int
parray		addr-parray 	addr-a[0]		a pointer to an array of 10 ints
ap1 		addr-ap			addr-ap1[0]		an array of 3 pointers to ints
ap1[0]		addr-ap1[0]		addr-x			an int reference to address x
ap1[1]		addr-ap1[1]		addr-a[0]		assigned the pointer to an int
ap1[2]		addr-ap1[2]		addr-b[0]		a pointer that points to an int
ap2 		addr-ap2		addr-ap2[0]		an array of 2 pointers to arrays of 10 ints
ap2[0]		addr-ap2[0]		addr-a[0]		a reference to an int
ap2[1]		addr-ap2[1]		addr-a[0]		a pointer to a pointer to an int

(b) Will the program successfully compile if we substitute line 17 with the following statement? Why or why not?
int (* parray) [10] = &b;

No, because there is an error: cannot convert 'int (*)[5]' to 'int (*)[10]' in initialization

(c) Will the program successfully compile if we substitute line 17 with the following statement? Why or why not?
int (* parray) [] = &b;

No, because there is an error: error: cannot convert 'int (*)[5]' to 'int (*)[]' in initialization

(d) Will the program successfully compile if we substitute line 25 with the following statement? Why or why not?
ap2[0] = &(*parray);

Yes, because ap2[0] successfully maps to the reference of the pointer to parray which is legal.

-----------------------------------------------------
7. Functions, Pointers, and Tricky Declarations Activity

1.
$ ./functions_pointers_and_tricky_declarations_activity
22
11

2. why is &x used for the function parameter on line 16?
To create its own separate reference, it is sending a reference to the function

3.

Declaration 				Meaning
int x; 						x is an int
int * x; 					x is a pointer to an int
char ** x;					x is a pointer to a pointer to a char
int * x [5];				x is a pointer to an array of 5 ints
int (* x) [5]; 				x is a pointer to an array of 5 ints
int (* x [5]) [5];			x is an array of 5 pointers to to ints
int * (* x [5]) [5]; 		x is an array of 5 pointers to arrays of 5 pointers to ints
int x();					x is a function of type int no parameters
int x(int);					x is a function of type int with int parameter
int * x();					x is a pointer to a function of type int with no parameter
int * x(int *);				x is a pointer to a function of type int with an int pointer parameter
int (* x)();				x is a pointer to a function of type int with no parameter
int ** (* x)(int **);		x is a pointer to an int function that contains pointer pf an int type
int (* x [5])();			x is a pointer to a function to an array of 5 ints with no parameters
int * ((* x) [5])();		x is a pointer to an array of 5 ints that points to a function with no parameters


----------------------------------------------------
8. Const Pointers Activity

1.

$ make
g++ -o making_assumptions making_assumptions_1.o
make: Circular arrays_and_pointers_activity1.o <- arrays_and_pointers_activity1.o dependency dropped.
g++ -Wall -std=c++14 -g -O0 -pedantic-errors -c const_pointer_activity.cpp
const_pointer_activity.cpp:14:6: error: read-only variable is not assignable
        *p2 = 11;
        ~~~ ^
const_pointer_activity.cpp:19:6: error: read-only variable is not assignable
        *p3 = 11;
        ~~~ ^
const_pointer_activity.cpp:20:5: error: read-only variable is not assignable
        p3 = &y;
        ~~ ^
3 errors generated.
make: *** [const_pointer_activity.o] Error 1




(a) Which statements of the code marked for part (a) are valid, and which statements are invalid? If a statement is invalid, please explain why.
int * p1 = &x;  // valid
*p1 = 11; 		// valid

(b) Which statements of the code marked for part (b) are valid, and which statements are invalid? If a statement is invalid, please explain why.
const int * p2 = &x; // valid
*p2 = 11; 			 // invalid, p2 is constant, its value can't be changed
p2 = &y; 			 // valid

(c) Which statements of the code marked for part (c) are valid, and which statements are invalid? If a statement is invalid, please explain why.
const int * const p3 = &x; // valid
*p3 = 11; 				   // invalid, p3 is constant, its value can't be changed
p3 = &y; 				   // invalid, p3 is constant pointer, it can't point to other address



2.

$ g++ -Wall -std=c++14 -g -O0 -pedantic-errors -c const_pointer_activity2.cpp
const_pointer_activity2.cpp:15:4: error: read-only variable is not assignable
        p3++;
        ~~^
const_pointer_activity2.cpp:18:4: error: array type 'int [2]' is not assignable
        a = b;
        ~ ^
const_pointer_activity2.cpp:19:3: error: cannot increment value of type
      'int [2]'
        a++;
        ~^
3 errors generated.


(a) Which statements of the code marked for part (a) are valid, and which statements are invalid? If a statement is
invalid, please explain why.

int * p1 = a;				// valid
const int * p2 = a;			// valid
const int * const p3 = a;	// invalid, the memory addr and data points to a constant, can't change it, compile error

(b) Which statements of the code marked for part (b) are valid, and which statements are invalid? If a statement is
invalid, please explain why.

p1++;	// valid
p2++;	// valid
p3++;	// valid

(c) Which statements of the code marked for part (c) are valid, and which statements are invalid? If a statement is
invalid, please explain why.

a = b;	// invalid array assignment
a++;	// invalid lvalue compile error, cannot assign value to something with no addr in memory.
(*a)++;	// valid




3.

$ g++ -Wall -std=c++14 -g -O0 -pedantic-errors -c const_pointer_activity3.cpp
const_pointer_activity3.cpp:21:7: error: expression is not assignable
        foo()++;
        ~~~~~^
const_pointer_activity3.cpp:26:2: error: called object type 'const int *' is not
      a function or function pointer
        (*p1)++;
        ^
const_pointer_activity3.cpp:27:7: error: expression is not assignable
        bar()++;
        ~~~~~^
const_pointer_activity3.cpp:28:10: error: read-only variable is not assignable
        (*bar())++;
        ~~~~~~~~^
const_pointer_activity3.cpp:33:2: error: called object type 'const int *' is not
      a function or function pointer
        (*p2)++;
        ^
const_pointer_activity3.cpp:34:7: error: expression is not assignable
        baz()++;
        ~~~~~^
6 errors generated.



(a) Which statements of the code marked for part (a) are valid, and which statements are invalid? If a statement is
invalid, please explain why.

int x = foo();  // valid
x++;			// valid
foo()++;		// compile error, lvalue required increment operand. Cannot apply increment to function

(b) Which statements of the code marked for part (b) are valid, and which statements are invalid? If a statement is
invalid, please explain why.

const int * p1 = bar();	// valid
p1++					// valid
(*p1)++;				// invalid pointer to a constant, cannot modify the value of p1
bar()++;				// invalid compile error, lvalue required as increment operand
(*bar())++;				// invalid, function returns constant value, cannot be modified compile error 

(c) Which statements of the code marked for part (c) are valid, and which statements are invalid? If a statement is
invalid, please explain why.

const int * p2 = baz(); // valid
p2++		// valid
(*p2)++;	// invalid declares constant pointer of type int, function returns constant value cannot modify, compile error
baz()++;	// invalid compile error, lvalue required as increment operand, cannot apply increment operator on function
(*baz())++;	// valid


